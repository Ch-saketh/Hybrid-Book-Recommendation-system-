# -*- coding: utf-8 -*-
"""search engine (sd).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FO2DOXtgoYixgr1lWS-rZ96JWvKM_JVj

# LOADING DATASET
"""

!pip install kaggle

from google.colab import files
files.upload()

#create the . kaggle directory in the home directory  , if it doesn't already exists
!mkdir -p ~/.kaggle
#copy the kaggle.json file to the new directory
!cp kaggle.json ~/.kaggle/
#600 meanse read and write permissions only for the owner , no permissions for others
!chmod 600 ~/.kaggle/kaggle.json

import kagglehub

# Download latest version
path = kagglehub.dataset_download("dylanjcastillo/7k-books-with-metadata")

print("Path to dataset files:", path)

"""# USING PANDAS AND OS TO READ THE CSV FILE WHICH IS DOWLAODED"""

import os
print('dataset files : ')
print(os.listdir(path))

import os
import pandas as pd

# Join the path and file name
bk_data_path = os.path.join(path, 'books.csv')
print("Path to data file:", bk_data_path)

# Read the CSV file into a DataFrame
bk_data = pd.read_csv(bk_data_path)

# Display the first few rows of the DataFrame
print(bk_data.head())

df = pd.DataFrame(bk_data)
df

"""# DATA CLEANING"""

df.columns

!pip install scikit-learn pandas numpy

import pandas as pd

# Load dataset
books_df = pd.read_csv(f"{path}/books.csv")  # Adjust filename if different

# Drop missing values in important columns
books_df = books_df.dropna(subset=['title', 'categories', 'description'])

# Reset index
books_df.reset_index(drop=True, inplace=True)

print("Dataset after cleaning:", books_df.shape)

# Remove rows where the description is missing or useless
df = df.dropna(subset=['description'])
df = df[df['description'].str.strip() != "."]
df = df[df['description'].str.len() > 10]  # Ensure descriptions have meaning

"""# "Feature Engineering for Text Similarity"
"""

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Combine title, categories, and description
books_df['combined_features'] = books_df['title'] + " " + books_df['categories'] + " " + books_df['description']

# Convert text into TF-IDF features
vectorizer = TfidfVectorizer(stop_words='english')
tfidf_matrix = vectorizer.fit_transform(books_df['combined_features'])

# Compute cosine similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

df['combined_features'] = df['description'].fillna('') + " " + df['categories'].fillna('')

"""#  Recommendation Function

"""

def recommend_books(book_title, num_recommendations=5):
    # Find the book index
    idx = books_df[books_df['title'].str.lower() == book_title.lower()].index

    if len(idx) == 0:
        return "Book not found in dataset."

    idx = idx[0]

    # Get similarity scores
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get indices of top similar books
    sim_indices = [i[0] for i in sim_scores[1:num_recommendations+1]]

    # Return recommended books
    return books_df.iloc[sim_indices][['title', 'authors', 'categories', 'average_rating']]

# Example usage
print(recommend_books("The Great Gatsby"))

"""# Content-Based Book Recommendation System Using TF-IDF and Cosine Similarity"""

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Step 1: Load dataset
df = pd.read_csv(bk_data_path)  # Update path if needed
df = df.dropna(subset=['title', 'description', 'categories'])  # Drop missing values

# Step 2: Create a text-based feature by combining description + category
df['content'] = df['description'] + " " + df['categories']

# Step 3: Convert text into TF-IDF vectors
vectorizer = TfidfVectorizer(stop_words='english')
tfidf_matrix = vectorizer.fit_transform(df['content'])

# Step 4: Compute cosine similarity between books
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Function to get book recommendations
def recommend_books(book_title, num_recommendations=5):
    if book_title not in df['title'].values:
        return "Book not found in dataset!"

    # Find the index of the given book
    idx = df[df['title'] == book_title].index[0]

    # Get similarity scores
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Sort books by similarity score
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:num_recommendations+1]

    # Get book indices
    book_indices = [i[0] for i in sim_scores]

    # Return recommended books
    return df.iloc[book_indices][['title', 'description', 'categories']]

# Example Usage: Get recommendations for a book
book_name = "The Great Gatsby"  # Change this to any book from your dataset
recommendations = recommend_books(book_name)
print(recommendations)

"""#Displaying Recommended Books Using Cosine Similarity Results

"""

def recommend_books(book_title, num_recommendations=5):
    if book_title not in df['title'].values:
        return "Book not found in dataset!"

    idx = df[df['title'] == book_title].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:num_recommendations+1]
    book_indices = [i[0] for i in sim_scores]

    # Convert to a DataFrame before returning
    return pd.DataFrame(df.iloc[book_indices][['title', 'description', 'categories']])

# Example Usage
book_name = "The Great Gatsby"  # Change this to any book from your dataset
recommendations = recommend_books(book_name)
display(recommendations)  # Properly display as DataFrame

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Vectorizing the cleaned 'content' column
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['content'])

# Compute cosine similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

recommendations = recommend_books("The Great Gatsby")
display(recommendations)

"""# Text Vectorization and Similarity Computation Using TF-IDF and Cosine Similarity

#  Why We Used TF-IDF + Cosine Similarity:
TF-IDF Vectorization

Transforms the combined text (description + category) into numerical vectors.

Gives higher weight to unique words, and lower weight to common ones like "the", "is".

Cosine Similarity

Measures the angle between vectors to check how similar two books are.

Output is a similarity score between 0 and 1, where 1 means exactly similar.
"""

# Combine text features into a single column for vectorization
books_df['combined_features'] = (
    books_df['title'].fillna('') + ' ' +
    books_df['authors'].fillna('') + ' ' +
    books_df['categories'].fillna('') + ' ' +
    books_df['description'].fillna('')
)

from sklearn.feature_extraction.text import TfidfVectorizer

tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(books_df['combined_features'])

recommendations = recommend_books("The Great Gatsby")
display(recommendations)

"""** Fix: Use a Hybrid Model (TF-IDF + Metadata Similarity)
Instead of only using TF-IDF, let's combine book metadata to improve recommendations.

🔹 Step 1: Create a Combined Features Column **

# 🔹 Combining Book Features for Text-Based Similarity
"""

df['combined_features'] = df['title'] + " " + df['authors'] + " " + df['categories'] + " " + df['description']
df['combined_features'] = df['combined_features'].fillna('')  # Fill missing values

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Apply TF-IDF on combined features
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['combined_features'])

# Compute cosine similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

recommendations = recommend_books("The Great Gatsby")
display(recommendations)

df['authors'] = df['authors'].fillna('')
df['categories'] = df['categories'].fillna('')

from sklearn.feature_extraction.text import CountVectorizer

count_vectorizer = CountVectorizer(stop_words='english')

count_matrix = count_vectorizer.fit_transform(df['authors'] + " " + df['categories'])

"""#  Hybrid Feature Representation: Combining Textual and Categorical Data for Recommendations"""

from sklearn.feature_extraction.text import CountVectorizer

# Use CountVectorizer for categorical data (authors + categories)
count_vectorizer = CountVectorizer(stop_words='english')
count_matrix = count_vectorizer.fit_transform(df['authors'] + " " + df['categories'])

# TF-IDF for text-based features (title + description)
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['title'] + " " + df['description'])

# Combine both similarity matrices
from scipy.sparse import hstack
combined_matrix = hstack([tfidf_matrix, count_matrix])

# Compute similarity
cosine_sim = cosine_similarity(combined_matrix, combined_matrix)

"""#  Interactive Book Recommendation System with Visual Ratings and Descriptions"""

import pandas as pd
import numpy as np
import ipywidgets as widgets
from IPython.display import display, HTML
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Load dataset
df.fillna("", inplace=True)
df['title'] = df['title'].str.lower()
df['ratings_count'] = df['ratings_count'].astype(str)
df['average_rating'] = df['average_rating'].astype(str)

# TF-IDF Vectorizer
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['title'] + " " + df['description'])
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Star rating
def star_rating(rating):
    percentage = (float(rating) / 5) * 100

    return f'''
    <div style="
        display: inline-block;
        position: relative;
        font-size: 20px;
        font-family: Arial;
        color: lightgray;">
        <div style="
            position: absolute;
            overflow: hidden;
            white-space: nowrap;
            width: {percentage}%;
            color: gold;">
            ★★★★★
        </div>
        ★★★★★
    </div>
    <span style="color: black; font-weight: bold;"> {float(rating):.1f}/5</span>
    '''

# Closest match
def find_closest_match(book_title):
    book_title = book_title.lower().strip()
    matches = df[df['title'].str.contains(book_title, na=False, case=False)]
    return matches if not matches.empty else None

# Recommend books
def recommend_books(book_title, num_recommendations=5):
    matches = find_closest_match(book_title)
    if matches is None:
        return "Book not found! Try another title."

    idx = matches.index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:num_recommendations+1]
    book_indices = [i[0] for i in sim_scores]
    recommended_books = df.iloc[book_indices]
    return matches.iloc[0], recommended_books

# Display books
def display_books(searched_book, recommended_books):
    searched_style = "background-color: #ccffcc; border: 2px solid green; padding: 15px; margin: 10px; width: 90%; border-radius: 12px;"
    recommended_style = "background-color: #fff3e0; border: 2px solid #ff6600; padding: 15px; margin: 10px; width: 90%; border-radius: 12px;"

    html = "<h2 style='color: green;'>Searched Book:</h2>"

    html += f"""
    <div style="{searched_style}">
        <img src="{searched_book['thumbnail']}" alt="Book Image" style="height:120px; float:left; margin-right:15px;">
        <div style="overflow: hidden;">
            <strong style="font-size:20px; color: black;">{searched_book['title'].title()}</strong><br>
            <b style="color: black;">Author:</b> <span style="color: black;">{searched_book['authors']}</span><br>
            <b style="color: black;">Genre:</b> <span style="color: black;">{searched_book.get('categories', 'Unknown')}</span><br>
            <b style="color: black;">Rating:</b> <span style="color: #ffcc00; font-size: 18px;">{star_rating(searched_book['average_rating'])}</span><br><br>
            <em style="font-size: 16px; color: black;">{searched_book['description']}</em>
        </div>
    </div>
    <div style="clear: both;"></div>
    """

    html += "<h2 style='color: orange;'>Recommended Books:</h2>"

    for _, row in recommended_books.iterrows():
        html += f"""
        <div style="{recommended_style}">
            <img src="{row['thumbnail']}" alt="Book Image" style="height:120px; float:left; margin-right:15px;">
            <div style="overflow: hidden;">
                <strong style="font-size:20px; color: black;">{row['title'].title()}</strong><br>
                <b style="color: black;">Author:</b> <span style="color: black;">{row['authors']}</span><br>
                <b style="color: black;">Genre:</b> <span style="color: black;">{row.get('categories', 'Unknown')}</span><br>
                <b style="color: black;">Rating:</b> <span style="color: #ffcc00; font-size: 18px;">{star_rating(row['average_rating'])}</span><br><br>
                <em style="font-size: 16px; color: black;">{row['description']}</em>
            </div>
        </div>
        <div style="clear: both;"></div>
        """

    display(HTML(html))


# Input box
search_box = widgets.Text(placeholder="Type a book name...", description="Book:")
search_button = widgets.Button(description="Search", button_style='success')

def on_search_click(b):
    title = search_box.value.strip()
    if title:
        result = recommend_books(title)
        if isinstance(result, str):
            display(HTML(f"<h3 style='color: red;'>{result}</h3>"))
        else:
            searched_book, recommendations = result
            display_books(searched_book, recommendations)

search_button.on_click(on_search_click)
display(widgets.HBox([search_box, search_button]))

import pandas as pd
import numpy as np
import ipywidgets as widgets
from IPython.display import display, HTML
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Load dataset
df.fillna("", inplace=True)
df['title'] = df['title'].str.lower()
df['ratings_count'] = df['ratings_count'].astype(str)
df['average_rating'] = df['average_rating'].astype(str)

# TF-IDF Vectorizer
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['title'] + " " + df['description'])
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Star rating
def star_rating(rating):
    percentage = (float(rating) / 5) * 100
    return f'''
    <div style="
        display: inline-block;
        position: relative;
        font-size: 20px;
        font-family: Arial;
        color: lightgray;">
        <div style="
            position: absolute;
            overflow: hidden;
            white-space: nowrap;
            width: {percentage}% ;
            color: gold;">
            ★★★★★
        </div>
        ★★★★★
    </div>
    <span style="color: black; font-weight: bold;"> {float(rating):.1f}/5</span>
    '''

# Closest match
def find_closest_match(book_title):
    book_title = book_title.lower().strip()
    matches = df[df['title'].str.contains(book_title, na=False, case=False)]
    return matches if not matches.empty else None

# Recommend books
def recommend_books(book_title, num_recommendations=5):
    matches = find_closest_match(book_title)
    if matches is None:
        return "Book not found! Try another title."
    idx = matches.index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:num_recommendations+1]
    book_indices = [i[0] for i in sim_scores]
    recommended_books = df.iloc[book_indices]
    return matches.iloc[0], recommended_books

# Display books
def display_books(searched_book, recommended_books):
    searched_style = "background-color: #ccffcc; border: 2px solid green; padding: 15px; margin: 10px; width: 90%; border-radius: 12px;"
    recommended_style = "background-color: #fff3e0; border: 2px solid #ff6600; padding: 15px; margin: 10px; width: 90%; border-radius: 12px;"

    html = "<h2 style='color: green;'>Searched Book:</h2>"

    html += f"""
    <div style="{searched_style}">
        <img src="{searched_book['thumbnail']}" alt="Book Image" style="height:120px; float:left; margin-right:15px;">
        <div style="overflow: hidden;">
            <strong style="font-size:20px; color: black;">{searched_book['title'].title()}</strong><br>
            <b style="color: black;">Author:</b> <span style="color: black;">{searched_book['authors']}</span><br>
            <b style="color: black;">Genre:</b> <span style="color: black;">{searched_book.get('categories', 'Unknown')}</span><br>
            <b style="color: black;">Rating:</b> <span style="color: #ffcc00; font-size: 18px;">{star_rating(searched_book['average_rating'])}</span><br><br>
            <em style="font-size: 16px; color: black;">{searched_book['description']}</em>
        </div>
    </div>
    <div style="clear: both;"></div>
    """

    if not recommended_books.empty:
        html += "<h2 style='color: orange;'>Recommended Books:</h2>"
        for _, row in recommended_books.iterrows():
            html += f"""
            <div style="{recommended_style}">
                <img src="{row['thumbnail']}" alt="Book Image" style="height:120px; float:left; margin-right:15px;">
                <div style="overflow: hidden;">
                    <strong style="font-size:20px; color: black;">{row['title'].title()}</strong><br>
                    <b style="color: black;">Author:</b> <span style="color: black;">{row['authors']}</span><br>
                    <b style="color: black;">Genre:</b> <span style="color: black;">{row.get('categories', 'Unknown')}</span><br>
                    <b style="color: black;">Rating:</b> <span style="color: #ffcc00; font-size: 18px;">{star_rating(row['average_rating'])}</span><br><br>
                    <em style="font-size: 16px; color: black;">{row['description']}</em>
                </div>
            </div>
            <div style="clear: both;"></div>
            """

    display(HTML(html))

# Book search UI
search_box = widgets.Text(placeholder="Type a book name...", description="Book:")
search_button = widgets.Button(description="Search", button_style='success')

def on_search_click(b):
    title = search_box.value.strip()
    if title:
        result = recommend_books(title)
        if isinstance(result, str):
            display(HTML(f"<h3 style='color: red;'>{result}</h3>"))
        else:
            searched_book, recommendations = result
            display_books(searched_book, recommendations)

search_button.on_click(on_search_click)
display(widgets.HBox([search_box, search_button]))

# -------------- 🔥 AUTHOR SEARCH SECTION 🔥 ----------------

# Search books by author
def search_books_by_author(author_name):
    author_name = author_name.lower().strip()
    matches = df[df['authors'].str.contains(author_name, na=False, case=False)]
    return matches if not matches.empty else None

# Author search UI
author_box = widgets.Text(placeholder="Type an author name...", description="Author:")
author_button = widgets.Button(description="Search Author", button_style='info')

def on_author_search_click(b):
    author = author_box.value.strip()
    if author:
        matches = search_books_by_author(author)
        if matches is None:
            display(HTML(f"<h3 style='color: red;'>Author not found! Try another name.</h3>"))
        else:
            display(HTML(f"<h2 style='color: blue;'>Books by {author.title()}:</h2>"))
            for _, book in matches.iterrows():
                display_books(book, pd.DataFrame())  # empty recommendation for author search

author_button.on_click(on_author_search_click)
display(widgets.HBox([author_box, author_button]))



!pip install streamlit pyngrok

def search_books(query):
    # Use your TF-IDF vectorizer and cosine similarity here
    return ["Book 1", "Book 2", "Book 3"]

import streamlit as st

# Your search logic
def search_books(query):
    return ["Naruto", "Attack on Titan", "One Piece"]

# UI
st.set_page_config(page_title="Anime Book Search", layout="wide")
st.title("📚 Anime Book Search Engine")

query = st.text_input("Enter your search query:")

if st.button("Search"):
    results = search_books(query)
    st.subheader("🔍 Search Results:")
    for result in results:
        st.markdown(f"- {result}")

!pip install streamlit pyngrok

import streamlit as st
st.markdown(
    """
    <style>
    .stTextInput > div > div > input {
        border: 2px solid #ff4b4b;
        border-radius: 10px;
        padding: 8px;
    }

    div.stButton > button {
        background-color: #ff4b4b;
        color: white;
        border: none;
        border-radius: 10px;
        padding: 10px 20px;
        font-weight: bold;
    }

    div.stButton > button:hover {
        background-color: #ff1c1c;
    }
    </style>
    """,
    unsafe_allow_html=True
)

# Inject custom CSS for styling the input box
st.markdown(
    """
    <style>
    .stTextInput > div > div > input {
        border: 2px solid #ff4b4b;
        border-radius: 10px;
        padding: 8px;
    }
    </style>
    """,
    unsafe_allow_html=True
)

# Title and input
st.title("📚 Anime Book Search Engine")

# Input box
query = st.text_input("Enter your search query:")

# Dummy function for now
def search_books(query):
    return ["Naruto", "Attack on Titan", "One Piece"]

# Search button
if st.button("Search"):
    results = search_books(query)
    st.subheader("🔍 Search Results:")
    for result in results:
        st.markdown(f"- {result}")

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel

# Load your book data and TF-IDF model here
# Example dummy data
book_titles = ["Harry Potter", "Lord of the Rings", "The Hobbit", "Game of Thrones"]
book_desc = [
    "A young wizard in a magical school.",
    "A journey with a magical ring.",
    "A hobbit goes on an adventure.",
    "A story of power and thrones."
]

vectorizer = TfidfVectorizer()
tfidf_matrix = vectorizer.fit_transform(book_desc)

def search_books(query):
    query_vec = vectorizer.transform([query])
    cosine_similarities = linear_kernel(query_vec, tfidf_matrix).flatten()
    top_indices = cosine_similarities.argsort()[-5:][::-1]
    results = [(book_titles[i], cosine_similarities[i]) for i in top_indices if cosine_similarities[i] > 0]
    return results

st.title("📚 Book Search Engine")

query = st.text_input("Enter a book description or keywords")
search = st.button("Search")

if search and query:
    with st.spinner("Searching..."):
        results = search_books(query)

    if results:
        st.markdown("---")
        st.subheader("Top Matches:")
        for title, score in results:
            st.markdown(f"""
            <div style="background-color:#f9f9f9;padding:15px;border-radius:10px;margin-bottom:10px;">
                <strong>{title}</strong><br>
                <span style="font-size: 12px;">Similarity: {score:.2f}</span>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.warning("No matching books found.")

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import streamlit as st

# Load dataset
df = pd.read_csv(bk_data_path)  # Update path if needed
df = df.dropna(subset=['title', 'description'])

# Combine relevant text fields
df['text'] = df['title'] + " " + df['description']

# TF-IDF Vectorization
vectorizer = TfidfVectorizer(stop_words='english')
tfidf_matrix = vectorizer.fit_transform(df['text'])

# Function to search books
def search_books(query, top_n=5):
    query_vec = vectorizer.transform([query])
    similarity = cosine_similarity(query_vec, tfidf_matrix).flatten()
    indices = similarity.argsort()[::-1][:top_n]
    results = df.iloc[indices][['title', 'description']]
    return results

# Streamlit UI
st.set_page_config(page_title="Book Search Engine", layout="centered")
st.title("📚 Book Search Engine")
st.markdown("Enter keywords, book titles, or topics:")

query = st.text_input("Search books here...")

if query:
    results = search_books(query)
    st.subheader("Top Results:")
    for i, row in results.iterrows():
        st.markdown(f"**{row['title']}**")
        st.markdown(f"*{row['description'][:300]}...*")
        st.markdown("---")

pip install pandas joblib

import pandas as pd
from joblib import dump

# Load and preprocess your dataset (replace with your actual code)
books = pd.read_csv(bk_data_path)
books['title'] = books['title'].str.lower()  # Example preprocessing

# Save the processed dataset to a .pkl file
dump(books, 'books_search_engine.pkl')

from flask import Flask, request, jsonify
from joblib import load

app = Flask(__name__)

# Load the preprocessed dataset (FASTER than reading CSV)
books = load('books_search_engine.pkl')  # Replace with your .pkl filename

@app.route('/search')
def search_books():
    query = request.args.get('q', '').lower()  # Lowercase to match preprocessed data
    results = books[books['title'].str.contains(query, na=False)]
    return jsonify(results.head(10).to_dict(orient='records'))

if __name__ == '__main__':
    app.run(debug=True)

